/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package poker;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import poker.Dealer.Card;
import poker.Dealer.Hand;
import poker.Dealer.NewDeal;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Properties;
import javax.swing.JFrame;
import poker.Dealer.Hand.hands;
import poker.GFX.*;


/**
 * Manages the phases of a game, and creates instance of NewDeal and a JFrame for GFX.
 * Defines an event handler for (any) key presses.
 * Contains actions for phase states: startGame, preFlop, Flop, turn, river and OnYourBacks.
 * Also contains methods for sorting cards and analysing which player has the best hand. 
 * @author Tim
 */
public class PokerManager {
    
    // JFrame window is initialised in PokerManager constructor (newGame in Poker main class).
    private static JFrame f;

    // Constructs a this newDeal instance, which constructs Hand (player) instances 
    // that are assigned cards from the static deckOfCards (in DeckOfCards class).
    public NewDeal thisDeal;  
    
    // Unique gameId for each hand, extracted from poker.properties file.
    private static String gameID;
    
    // Initialises PHASE to the START state.
    private static PhaseTypes phase = PhaseTypes.START;

    private static Card[] community;  // the 5 community cards for this game. 
    private static Hand[] playerList; // List of 8 player Hand class instances.
    public ArrayList<Hand> winnerList; // list of top hands, generated by analyseWinner() method.

    private String BestHandType = "HIGHCARD";  // the best hand per phase, initialised at highCard (bottom hand rank).

    
    // Sets a keyListener (any key) which is used mid-game to trigger the advancePhase() method.
    KeyListener keyList = new KeyListener() {
        @Override
        public void keyReleased(KeyEvent ke) {
//            incrementPhase();
            advancePhase();
        }

        @Override
        public void keyPressed(KeyEvent ke) {
//            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void keyTyped(KeyEvent ke) {
//            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }
    };

    // Declares the 6 game states (phases of a hand).
    public enum PhaseTypes {
        START,
        PREFLOP,
        FLOP,
        TURN,
        RIVER,
        RESULT;
    }

    // Constructs a PokerManager instance and defines JFrame to draw on.
    public PokerManager(){
        f = new JFrame("Java Poker Simulation");
        f.addWindowListener(new WindowAdapter(){
        @Override
        public void windowClosing(WindowEvent e) {
                System.exit(0);
                }
            }
        );
        f.add(new GFX_SetScene());
        f.pack();
        f.setVisible(true);

        f.addKeyListener(keyList); // Key press triggers advancePhase.
        
        startGame();  // Initiates actions of the START phase state.
        
    }
    
    
    
    // advancePhase is called by key listener event handler, advances the game STATE.
    public final void advancePhase(){

        // Add 1 to phase Ordinal to set new phase
        incrementPhase();

        // Call respective phase method for new phase STATE.
        switch (phase) {
            case START:  
                startGame();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            case PREFLOP:  
                preFlop();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            case FLOP:  
                flop();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            case TURN:  
                turn();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            case RIVER:  
                river();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            case RESULT:  
                onYourBacks();
                f.repaint(); // Redraw JFrame with new GFX assignments.
                break;
            default:
                break;
        }
    }
    
    // Triggered by AdvancePhase() KeyListener, increments the phase STATE forwards.
    private void incrementPhase() {
        if(phase.ordinal() == 5){
            phase = PhaseTypes.START; // For starting new games after a game has ended.
        }
        else{
            phase = PhaseTypes.values()[phase.ordinal()+1];
        }
    }

    // Called by instance of PokerManager. Instantiates a newDeal and prints hands.
    private void startGame() {
        thisDeal = new NewDeal();
        community = thisDeal.community.getCommunityCards();
        playerList = thisDeal.getListOfPlayers();
        
        GFX_SetScene.setPLabel("NEW DEAL!");
        GFX_SetScene.setBHLabel("BEST HAND");
        GFX_SetScene.setMLabel("It's a new dawn, it's a new day, it's a new life for me.");
        GFX_SetScene.updateCards(phase);

        System.out.println("Phase = " + phase);
        for (int i=0;i<8;i++){
            System.out.println("Player " + (i+1) + " has the " 
                               + playerList[i].getPlayerHand());
        }
        System.out.println("The community cards are " + 
                thisDeal.community.getCommunityHand());
 
        // For extracting the gameID value from poker.properties file.
        Properties prop = new Properties();
        InputStream input = null;
        OutputStream output = null;

        // Load poker.properties and assign/increment GameID to gameIdLabel
        try {

            String filename = "poker.properties";
                    
            input = PokerManager.class.getClassLoader().getResourceAsStream(filename);

            if(input==null){
    	        System.out.println("Unable to load " + filename + " as input.");
                return;
            }                      

            output = new FileOutputStream(filename);

            // load data props file.
            prop.load(input);

            // Retrieve GameID and assign to static gameID var.
            gameID = prop.getProperty("GameID", "69");

            // Set GFX gameIdLabel using static gameID var.
            GFX_SetScene.setGameIdLabel(gameID);
            
            // Create a new gameID string and increment by 1.
            String temp = String.valueOf(Integer.valueOf(gameID) +1);

            output = new FileOutputStream("./build/classes/poker.properties");
            
            // Set properties GameID val (in-memory) to (temp) incremented gameID val.
            prop.setProperty("GameID", temp);
            
            // Save properties to project root folder.
            prop.store(output, null);
        } 
        catch (IOException io) {
            io.printStackTrace();
        } 
        finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } 
            if (output != null) {
                try {
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // Game state that follows START - where players are dealt their hole cards.
    private void preFlop(){
        for(Hand p : playerList) {
            HandCalculator HC = new HandCalculator(p);
            HC = null;
        }
        analyseWinner();
        GFX_SetScene.setPLabel("PRE-FLOP!");  
        GFX_SetScene.setBHLabel(BestHandType);
        GFX_SetScene.updateCards(phase);
        System.out.println("Phase = " + phase);        
    }
    
    // Game state following PREFLOP, where the 1st 3 community cards are revealed.
    private void flop(){
        // Add 3 x flop cards to each player hand
        for (int i=0; i < 8; i++) {
            playerList[i].addFlopCards(community[0],
                                       community[1],
                                       community[2]);
            }
        for(Hand p : playerList) {
            HandCalculator HC = new HandCalculator(p);
        }
        analyseWinner();        
        GFX_SetScene.setPLabel("THE FLOP!");        
        GFX_SetScene.setBHLabel(BestHandType);
        GFX_SetScene.updateCards(phase);        
        System.out.println("Phase = " + phase);
    }

    // Game state that follows the FLOP, where the 4th community card is revealed.
    private void turn(){
        // Add Turn card to each player hand
        for (int i=0; i < 8; i++) {
            playerList[i].addTurnCard(community[3]);
        }
        for(Hand p : playerList) {
            HandCalculator HC = new HandCalculator(p);
        }
        analyseWinner();        
        GFX_SetScene.setPLabel("THE TURN!");
        GFX_SetScene.setBHLabel(BestHandType);
        GFX_SetScene.updateCards(phase);
        System.out.println("Phase = " + phase);
    }

    // Game state that follows the TURN, where the 5th (final) community card is revealed.
    private void river(){
        // Add River card to each player hand        
        for (int i=0; i < 8; i++) {
            playerList[i].addRiverCard(community[4]);
        }
        for(Hand p : playerList) {
            HandCalculator HC = new HandCalculator(p);
            HC.printBestPlayerHand(p);
        }
        analyseWinner();        
        GFX_SetScene.setPLabel("THE RIVER!");
        GFX_SetScene.setBHLabel(BestHandType);
        GFX_SetScene.updateCards(phase);
        System.out.println("Phase = " + phase);
    }
    
    // Final game state that follows the RIVER, which declares the winner(s) of this game.
    private void onYourBacks(){
        analyseWinner();
        GFX_SetScene.setPLabel("RESULT");
        GFX_SetScene.updateCards(phase);
        System.out.println("Phase = " + phase);        
    }

    private int getPhaseOrdinal(){
        return PokerManager.phase.ordinal();
    }

    // To calculate the topHandType and generate winnerList of top hands, 
    // then calls declareWinner().
    private void analyseWinner(){
        hands topHandType = poker.Dealer.Hand.hands.HIGHCARD;
        this.winnerList = new ArrayList<>();

        // Iterate through hands to calculate the topHandType.
        for(Hand hand : playerList){
            if(hand.getHandType().ordinal() > topHandType.ordinal()){
                topHandType = hand.getHandType();
            }
        }
        // Iterate through hands to add hands with topHandType to winnerList
        for(Hand hand : playerList){
            if(hand.getHandType().ordinal() == topHandType.ordinal()){
                winnerList.add(hand);
            }
        }
        declareWinner(winnerList);                    
    }

    // Analyse winnerList then print out the winning hands as a string.
    // Calling sortWinningHands deletes lesser hands. 
    private void declareWinner(ArrayList<Hand> wL){

        // Label string is used to print to log and to set message label in GFX.
        String label;
        
        // ... If one outright winner.
        if(wL.size() == 1){
            // Set player icons in GFX (star if winning hand else star filler)
            GFX_SetScene.setPlayerIcon(wL);
            Hand L1 = wL.get(0);
            BestHandType = L1.getHandTypeString();
                
            // Only declare winner at the end of the hand.
            if(phase == PhaseTypes.RESULT){
                label = "Player " + L1.getPlayerNum() 
                    + " takes this hand with a "
                    + L1.bestHand.get(0).getName() + " high "
                    + L1.getHandType() + "!";
                System.out.println(label);
                GFX_SetScene.setMLabel(label);
            }            
        }
        else {
            // Sorts and deletes lesser hands from wL
            wL = sortWinningHands(wL);

            // Post-sort, if there is a stand out winner.
            if(wL.size() == 1){
                // Set player icons in GFX (star if winning hand else star filler)
                GFX_SetScene.setPlayerIcon(wL);
                Hand L1 = wL.get(0);        
                BestHandType = L1.getHandTypeString();

                // Only declare winner at the end of the hand.
                if(phase == PhaseTypes.RESULT){
                    label = "Player " + L1.getPlayerNum() 
                        + " takes this hand with a "
                        + L1.getBestCard(0).getName() + " high "
                        + L1.getHandType() + "!";
                    System.out.println(label);
                    GFX_SetScene.setMLabel(label);
                }
            }
            
            // Post-sort, if there is a split pot. 
            else {
                // Set player icons in GFX (star if winning hand else use star filler)
                GFX_SetScene.setPlayerIcon(wL);

                Hand L1 = wL.get(0);
                BestHandType = L1.getHandTypeString();

                // Only declare winner at the end of the hand.
                if(phase == PhaseTypes.RESULT){
                
                    // Build a list of players numbers for use in split pot string.
                    // Structure of string differs depending on how many players.
                    ArrayList<Integer> wpL = new ArrayList<>();
                    String multiWin = "";
                    for (int i=0; i < wL.size(); i++){
                        wpL.add(wL.get(i).getPlayerNum());
                    }
                    for (int i=0; i< wpL.size(); i++){
                        if( i < 1){
                            multiWin = Integer.toString(wpL.get(i));
                        }
                        else if ( i < wpL.size() -1) {                  
                            multiWin = multiWin + ", " + wpL.get(i);
                        }
                        else {
                            multiWin = multiWin + " and " + wpL.get(i);
                        }
                    }

                    label = "Player's " + multiWin 
                        + " share this hand with a "
                        + L1.getBestCard(0).getName() + " high "
                        + L1.getHandType() + "!";
                        
                        System.out.println(label);
                        GFX_SetScene.setMessageFont(label);
                        GFX_SetScene.setMLabel(label);
                    }
                }
            }
    }
    
    // Called by declareWinners, returns the sorted winnerList with lesser hands deleted.
    private ArrayList<Hand> sortWinningHands(ArrayList<Hand> h){
        ArrayList<Hand> H = h; // Create reference to list of hands.
        H.iterator(); // Create an iterator.
        sortHandsComparator mySHC = new sortHandsComparator(0); // Set to first hand in list.
        Collections.sort(H, Collections.reverseOrder(mySHC)); // Sort hands on 1st 
        
        // Only iterate thru as many cards as are in the first hand 
        // for i loop is one card shorter than the number of cards as final code block executes for the last card.
        for(int i=0; i< h.get(0).getBestHand().size(); i++){
            // Refresh the iterator for new order of hands.
            Iterator<Hand> it = H.iterator(); 
            // No need to sort if there is only one hand in list.
            if(H.size() > 1){ 
                // Set the top ranking card as the standard.
                int highRank = H.get(0).getBestCard(i).getNum();
                // Iterate through each hand in H list of hands
                while(it.hasNext()){
                    // Set the rank of the card to compare against the standard.
                    int comp = it.next().getBestCard(i).getNum(); 

                    // Remove hand from the iteratorlist of hands if comparison is lower than the standard.
                    if(comp < highRank){
                        it.remove(); 
                    }
                }
                // When on the final loop of i.
                if(i < h.get(0).getBestHand().size() -1){
                    // Resort H for the last card.
                    mySHC = new sortHandsComparator(i+1);            
                    Collections.sort(H, Collections.reverseOrder(mySHC));
                }
            } 
        }
        return H;
    }

    // Custom comparator that compares Hands by the rank of cards.     
    class sortHandsComparator implements Comparator<Hand> {
        public int i;
        
        // Set to 0 or call using the i from for() loop (i refers to index in hand list).
        sortHandsComparator(int i) {
            this.i = i;
        }
        
        @Override
        public int compare(Hand a, Hand b){
            return a.bestHand.get(i).getNum() - b.bestHand.get(i).getNum();
        }
    } 
    
    public static Hand[] getThisDealPlayerList() {
        return playerList;
    }
    public static Card[] getThisDealCommunityList() {
        return community;
    }       
    public static String getPhase(){
        return phase.name();
    }
    
    // Called by GFX_SetScene update cards method to repaint frame.
    public static JFrame getJFrame(){
        return f;
    }
    
    // Extracts the gameID from poker.properties file, throws FileNotFoundException, IOException.
    private static void getAndSetGameID() {
        Properties prop = new Properties();
        InputStream input = null;
        OutputStream output = null;

        try {
            input = new FileInputStream("data.properties");
            output = new FileOutputStream("data.properties");

            // load data props file.
            prop.load(input);
            
            // Retrieve GameID and set to static gameID var.
            gameID = prop.getProperty("GameID");
            
            // Create a new gameID string and increment by 1.
            String temp = String.valueOf(Integer.valueOf(gameID) +1);

            // Set properties GameID val to (temp) incremented gameID val.
            prop.setProperty("GameID", temp);
            
            // Save properties to project root folder.
            prop.store(output, null);
            
        } catch (IOException io) {
        
            io.printStackTrace();
        
        } finally {
            // Tie up loose ends (close input and output streams.
            if (output != null) {
                try {
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (input != null) {
                try {
                    input.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }            
        }
    }
 
}